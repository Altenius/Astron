// Filename: Parser.yxx
// Created by: drose (05 Oct, 2000)
//

%{
	#include "file/LexerDefs.h"
	#include "file/ParserDefs.h"
	#include "File.h"
	#include "DistributedType.h"
	#include "NumericRange.h"
	#include "NumericType.h"
	#include "ArrayType.h"
	#include "Struct.h"
	#include "Class.h"
	#include "Field.h"
	#include "Method.h"
	#include "Parameter.h"
	#include "MolecularField.h"

	#include <unistd.h>
	#include <stdint.h> // Fixed width integer limits
	#include <math.h>   // Float INFINITY

	#define yyparse run_parser
	#define yylex run_lexer
	#define yyerror parser_error
	#define yywarning parser_warning
	#define yylval dcyylval
	#define yychar dcyychar
	#define yydebug dcyydebug
	#define yynerrs dcyynerrs

	// Because our token type contains objects of type std::string, which
	// require correct copy construction (and not simply memcpying), we
	// cannot use bison's built-in auto-stack-grow feature.  As an easy
	// solution, we ensure here that we have enough yacc stack to start
	// with, and that it doesn't ever try to grow.
	#define YYINITDEPTH 1000
	#define YYMAXDEPTH 1000

	namespace dclass   // open namespace dclass
	{
	

	static File* parsed_file = (File*)NULL;
	static std::string* parsed_value = (std::string*)NULL;

	/* Helper functions */
	static Parameter* param_with_modulus(Parameter* p, double mod);
	static Parameter* param_with_divisor(Parameter* p, uint32_t div);
	static std::string number_value(DataType type, double &number);
	static std::string number_value(DataType type, int64_t &number);
	static std::string number_value(DataType type, uint64_t &number);

////////////////////////////////////////////////////////////////////
// Defining the interface to the parser.
////////////////////////////////////////////////////////////////////

	void init_file_parser(std::istream& in, const std::string& filename, File& file)
	{
		dc_file = &file;
		dc_init_lexer(in, filename);
	}

	void init_value_parser(std::istream& in, const std::string& source, const Parameter* parameter, std::string& output)
	{
		output_value = &output;
		dc_init_lexer(in, source);
		dc_start_parameter_value();
	}

	void cleanup_parser()
	{
		dc_file = (File*)NULL;
		output_value = (std::string*)NULL;
	}

	int parser_error_count()
	{
		return lexer_error_count();
	}
	int parser_warning_count()
	{
		return lexer_warning_count();
	}

	void parser_error(const std::string &msg)
	{
		lexer_error(msg);
	}
	void parser_warning(const std::string &msg)
	{
		parser_error(msg);
	}
%}

/* Value tokens */
%token <u.uint64> UNSIGNED_INTEGER
%token <u.int64> SIGNED_INTEGER
%token <u.real> REAL
%token <str> STRING HEX_STRING IDENTIFIER
%token <u.keyword> KEYWORD

/* Initial Tokens */
// These special tokens are used to set the starting state of the parser.
//     The lexer places the appropriate one of these on the head of the input stream.
%token START_DC
%token START_PARAMETER_VALUE

/* Define keywords */
// Declaration Keywords
%token KW_DCLASS
%token KW_STRUCT
%token KW_FROM
%token KW_IMPORT
%token KW_TYPEDEF
%token KW_KEYWORD

// Type Keywords
%token KW_INT8
%token KW_INT16
%token KW_INT32
%token KW_INT64
%token KW_UINT8
%token KW_UINT16
%token KW_UINT32
%token KW_UINT64
%token KW_FLOAT32
%token KW_FLOAT64
%token KW_STRING
%token KW_BLOB
%token KW_CHAR


/* Abstract Nonterminals */
%type <u.dclass> dclass
%type <u.dstruct> dstruct
%type <u.field> atomic_field
%type <u.field> molecular_field
%type <u.parameter> parameter
%type <u.parameter> named_parameter
%type <u.parameter> unnamed_parameter

/* Concrete Nonterminals */
%type <u.parameter> param_w_typ // parameter w/ type only
%type <u.parameter> param_w_rng // parameter w/ type + range
%type <u.parameter> param_w_mod // parameter w/ type + modulus        (+rng)
%type <u.parameter> param_w_div // parameter w/ type + divisor        (+rng, +mod)
%type <u.parameter> param_w_nam // parameter w/ type + name           (+rng, +mod, +div)
%type <u.parameter> param_u_arr // parameter w/ type + array          (+rng, +mod, +div)
%type <u.parameter> param_u_def // parameter w/ type + default        (+rng, +mod, +div, +arr)
%type <u.parameter> param_n_arr // parameter w/ type + name + array   (+rng, +mod, +div)
%type <u.parameter> param_n_def // parameter w/ type + name + default (+rng, +mod, +div, +arr)

/* TODO: Categorize nonterminals */
%type <u.atomic> atomic_name
%type <u.dclass> dclass_name
%type <u.field> dclass_field
%type <u.field> struct_field
%type <u.datatype> type_token

%type <str> import_identifier
%type <str> import_path
%type <str> array
%type <str> array_value
%type <str> parameter_value
%type <u.uint32> char_or_uint
%type <u.uint32> small_unsigned_integer
%type <u.uint32> small_negative_integer
%type <u.real> char_or_number
%type <u.real> number
%type <range> double_range
%type <range> uint_range

%%

grammar
	: START_DC dc
	| START_PARAMETER_VALUE output_parameter_value
	;


dc	: empty
	| dc ';'
	| dc dclass
	{
		if(!dc_file->add_class($2))
		{
			yyerror("Duplicate class name: " + $2->get_name());
		}
	}
	| dc dstruct
	{
		if(!dc_file->add_struct($2))
		{
			yyerror("Duplicate class name: " + $2->get_name());
		}
	}
	| dc import
	| dc typedef_decl
	| dc keyword_decl
	;

output_parameter_value
	: parameter_value
	{
		output_value->assign($1);
	}
	;

import
	: KW_IMPORT import_identifier
	{
		dc_file->add_import_module($2);
	}
	| KW_FROM import_identifier KW_IMPORT
	{
		dc_file->add_import_module($2);
	}
	  import_symbol_list_or_star
	;


import_identifier
	: import_path
	| import_identifier '.' import_path
	{
		$$ = $1 + std::string(".") + $3;
	}
	;

import_path
	: IDENTIFIER
	| import_path '/' IDENTIFIER
	{
		$$ = $1 + std::string("/") + $3;
	}
	;


import_symbol_list_or_star
	: import_symbol_list
	| '*' { dc_file->add_import_symbol("*"); }
	;

import_symbol_list
	: import_path { dc_file->add_import_symbol($1); }
	| import_symbol_list ',' import_path { dc_file->add_import_symbol($3); }
	;

typedef_decl
	: KW_TYPEDEF named_parameter
	{
		if($2 != (Parameter*)NULL)
		{
			Typedef *dtypedef = new Typedef($2);
			if(!dc_file->add_typedef(dtypedef))
			{
				yyerror("Duplicate typedef name: " + dtypedef->get_name());
			}
		}
	}
	;

keyword_decl:
  KW_KEYWORD keyword_decl_list
;

keyword_decl_list:
  empty
| keyword_decl_list IDENTIFIER
{
	dc_file->add_keyword($2);
}
| keyword_decl_list KEYWORD
{
	// This keyword has already been defined.  But since we are now
	// explicitly defining it, clear its bitmask, so that we will have a
	// new hash code--doing this will allow us to phase out the
	// historical hash code support later.
	((Keyword *)$2)->clear_historical_flag();
}
;

dclass
	: KW_DCLASS IDENTIFIER
	{
		current_class = new Class(dc_file, $2);
	}
	  dclass_inheritance '{' dclass_fields '}'
	{
		current_class->as_class()->rebuild_fields();
		$$ = current_class->as_class();
		current_class = $<u.dclass>3;
	}
	;

dclass_name
	: IDENTIFIER
	{
		if(dc_file == (File *)NULL)
		{
			yyerror("No File available, so no class names are predefined.");
			$$ = NULL;
		}
		else
		{
			Struct *dc_struct = dc_file->get_class_by_name($1);
			if(dc_struct == (Class*)NULL)
			{
				yyerror("dclass '" + std::string($1) + "' has not been declared.");
			}

			Class* dc_class = dc_struct->as_class();
			if(dc_class == (Class*)NULL)
			{
				yyerror("dclass cannot inherit from a struct");
			}

			$$ = dc_class;
		}
	}
	;

dclass_inheritance
	: empty
	| ':' dclass_parents
	;

dclass_parents
	: dclass_name
	{
		if($1 != (Class*)NULL)
		{
			current_class->as_class()->add_parent($1);
		}
	}
	| dclass_parents ',' dclass_name
	{
		if($3 != (Class*)NULL)
		{
			current_class->as_class()->add_parent($3);
		}
	}
	;

dclass_fields
	: empty
	| dclass_fields ';'
	| dclass_fields dclass_field ';'
	{
		if($2 == (Field*)NULL)
		{
			// Pass this error up.
		}
		else if(!current_class->add_field($2))
		{
			yyerror("Duplicate field name: " + $2->get_name());
		}
	}
	;

dclass_field
	: atomic_field keyword_list
	{
		if($1 != (Field*)NULL)
		{
			if($1->get_name().empty())
			{
				yyerror("Field name required.");
			}
			$1->copy_keywords(current_keyword_list);
		}
		$$ = $1;
	}
	| molecular_field no_keyword_list
	| unnamed_parameter keyword_list
	{
		yyerror("Unnamed parameters are not allowed on a dclass");
		if($1 != (Field *)NULL)
		{
			$1->copy_keywords(current_keyword_list);
		}
		$$ = $1;
	}
	| named_parameter keyword_list
	{
		if($1 != (Field *)NULL)
		{
			$1->copy_keywords(current_keyword_list);
		}
		$$ = $1;
	}
	;

dstruct
	: KW_STRUCT IDENTIFIER
	{
		current_class = new Struct(dc_file, $2);
	}
	  '{' struct_fields '}'
	{
		$$ = current_class;
	}
	;

struct_fields
	: empty
	| struct_fields ';'
	| struct_fields struct_field
	{
		if($2 == (Field *)NULL)
		{
			// Pass this error up.
		}
		else if(!current_class->add_field($2))
		{
			yyerror("Duplicate field name: " + $2->get_name());
		}
	}
	;

struct_field
	: unnamed_parameter ';' { $$ = $1; }
	| named_parameter ';' { $$ = $1; }
	;

atomic_field
	: IDENTIFIER '('
	{
		if(current_class == (Class *)NULL)
		{
			yyerror("Cannot define a method outside of a struct or class.");
		}
		else
		{
			current_atomic = new AtomicField($1, current_class);
		}
	}
	  parameter_list ')'
	{
		$$ = current_atomic;
		current_atomic = $<u.atomic>3;
	}
	;

parameter_list
	: empty
	| nonempty_parameter_list
	;

nonempty_parameter_list
	: atomic_element
	| nonempty_parameter_list ',' atomic_element
	;

atomic_element
	: parameter
	{
		if($1 != (Parameter *)NULL)
		{
			current_atomic->add_element($1);
		}
	}
	;

named_parameter
	: param_w_nam { $$ = $1; }
	| param_n_arr { $$ = $1; }
	| param_n_def { $$ = $1; }
	;

unnamed_parameter
	: param_w_typ { $$ = $1; }
	| param_w_rng { $$ = $1; }
	| param_w_mod { $$ = $1; }
	| param_w_div { $$ = $1; }
	| param_u_arr { $$ = $1; }
	| param_u_def { $$ = $1; }
	;

parameter
	: named_parameter   { $$ = $1; }
	| unnamed_parameter { $$ = $1; }
	;

param_w_typ
	: type_token { $$ = current_parameter = new SimpleParameter($1);   }
	| IDENTIFIER
	{
		Typedef *dtypedef = dc_file->get_typedef_by_name($1);
		if(dtypedef == (Typedef*)NULL)
		{
			// Maybe it's a class name.
			Struct *dc_struct = dc_file->get_class_by_name($1);
			if(dc_struct != (Struct*)NULL)
			{
				if(dc_struct->as_class() != (Class*)NULL)
				{
					yyerror("Cannot use distributed class '" + $1 + "' as parameter type.");
				}
				else
				{
					// Create an implicit typedef for this.
					dtypedef = new Typedef(new StructParameter(dc_struct), true);
				}
			}
			else
			{
				yyerror("Cannot use undefined type '" + $1 + "' as parameter type.");
			}

			dc_file->add_typedef(dtypedef);
		}

		$$ = current_parameter = dtypedef->new_parameter();
	}
	;

param_w_rng
	: type_token '(' double_range ')'
	{
		SimpleParameter *simple_param = new SimpleParameter($1);
		if(simple_param == NULL
		|| simple_param->get_typedef() != (Typedef*)NULL)
		{
			yyerror("Ranges are only valid for numeric, string, or blob types.");
		}
		if(!simple_param->set_range($3))
		{
			yyerror("Inappropriate range for type.");
		}

		$$ = current_parameter = simple_param;
	}
	;

param_w_mod
	: param_w_typ '%' number { $$ = param_with_modulus($1, $3); }
	| param_w_rng '%' number { $$ = param_with_modulus($1, $3); }
	;

param_w_div
	: param_w_typ '/' small_unsigned_integer { $$ = param_with_divisor($1, $3); }
	| param_w_rng '/' small_unsigned_integer { $$ = param_with_divisor($1, $3); }
	| param_w_mod '/' small_unsigned_integer { $$ = param_with_divisor($1, $3); }
	;

param_w_nam
	: param_w_typ IDENTIFIER { $$ = $1; $1->set_name($2); }
	| param_w_rng IDENTIFIER { $$ = $1; $1->set_name($2); }
	| param_w_mod IDENTIFIER { $$ = $1; $1->set_name($2); }
	| param_w_div IDENTIFIER { $$ = $1; $1->set_name($2); }
	;

param_u_arr
	: param_w_typ '[' uint_range ']' { $$ = $1->append_array_specification($3); }
	| param_w_rng '[' uint_range ']' { $$ = $1->append_array_specification($3); }
	| param_w_mod '[' uint_range ']' { $$ = $1->append_array_specification($3); }
	| param_w_div '[' uint_range ']' { $$ = $1->append_array_specification($3); }
	;

param_n_arr
	: param_w_nam '[' uint_range ']' { $$ = $1->append_array_specification($3); }
	;

param_u_def
	: param_w_typ '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	| param_w_rng '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	| param_w_mod '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	| param_w_div '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	| param_u_arr '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	;

param_n_def
	: param_w_nam '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	| param_n_arr '=' parameter_value { $$ = $1; $1->set_default_value($3); }
	;

double_range
	: empty { $$ = NumericRange(); }
	| char_or_number { $$ = NumericRange($1, $1); }
	| char_or_number '-' char_or_number { $$ = NumericRange($1, $3); }
	| char_or_number number { $$ = NumericRange($1, $2); }
	;

uint_range
	: empty { $$ = NumericRange(); }
	| char_or_uint { $$ = NumericRange($1, $1); }
	| char_or_uint '-' char_or_uint { $$ = NumericRange($1, $3); }
	| char_or_uint small_negative_integer { $$ = NumericRange($1, $2); }
	;

char_or_uint
	: STRING
	{
		if($1.length() != 1)
		{
			yyerror("Single character required.");
			$$ = 0;
		}
		else {
			$$ = (unsigned char)$1[0];
		}
	}
	| small_unsigned_integer
	;

small_unsigned_integer
	: UNSIGNED_INTEGER
	{
		$$ = (unsigned int)$1;
		if($$ != $1)
		{
			yyerror("Number out of range.");
			$$ = 1;
		}
	}
	;

small_negative_integer
	: SIGNED_INTEGER
	{
		$$ = (unsigned int) - $1;
		if($1 >= 0)
		{
			yyerror("Syntax error while parsing small_negative_integer.");
		}
		else if($$ != -$1)
		{
			yyerror("Number out of range.");
			$$ = 1;
		}
	}
	;

number
	: UNSIGNED_INTEGER { $$ = (double)$1; }
	| SIGNED_INTEGER { $$ = (double)$1; }
	| REAL
	;

char_or_number
	: STRING
	{
		if($1.length() != 1)
		{
			yyerror("Single character required.");
			$$ = 0;
		}
		else
		{
			$$ = (double)(unsigned char)$1[0];
		}
	}
	| number
	;

value
	: empty
	| parameter_value
	| '(' method_value ')'
	{
		DataType type = current_parameter->get_datatype();
		if(type != m_method)
	}

parameter_value
	: SIGNED_INTEGER
	{
		$$ = number_value(current_parameter->get_datatype(), $1);
	}
	| UNSIGNED_INTEGER
	{
		$$ = number_value(current_parameter->get_datatype(), $1);
	}
	| REAL
	{
		$$ = number_value(current_parameter->get_datatype(), $1);
	}
	| STRING
	{
		DataType type = current_parameter->get_datatype();
		if(type == DT_string)
		{
			if($1.length() != current_parameter->get_size())
			{
				yyerror("Default value for fixed-length string has incorrect length.");
			}

	 		$$ = $1;
		}
		else if(type == DT_varstring) // DT_varstring
		{
			// TODO: Check for range limits
			// Prepend length tag
			sizetag_t length = $1.length();
			$$ = std::string((char*)&length, sizeof(sizetag_t)) + $1;
		}
		else
		{
			yyerror("Cannot use string value for non-string datatype.");
			$$ = $1;
		}
	}
	| HEX_STRING
	{
		// TODO: check for range limits... maybe?
		$$ = $1;
	}
	| '[' array ']' // array composition
	{
		DataType type = current_parameter->get_datatype();
		if(type == DT_vararray)
		{
			sizetag_t length = $2.length();
			$$ = std::string((char*)&length, sizeof(sizetag_t)) + $2;
		}
		else // DT_array
		{
			// TODO: Check range limits
			$$ = $2;
		}
	}
	| '{' array '}' // array composition -- deprecated, will turn into struct compositon
	{
		DataType type = current_parameter->get_datatype();
		if(type == DT_vararray)
		{
			sizetag_t length = $2.length();
			$$ = std::string((char*)&length, sizeof(sizetag_t)) + $2;
		}
		else if(type == DT_array)
		{
			// TODO: Check range limits
			$$ = $2;
		}
		else if(type == DT_struct)
		{
			yyerror("The {val} format is still parsed as an array value, values may not be properly validated or packed for a struct.");
			$$ = $2;
		}
		else
		{
			yyerror("Cannot use array composition as value for non-array type.");
			$$ = $2;
		}
	}
	;

array
	: empty { $$ = ""; }
	| array_value { $$ = $1; }
	;

array_value
	: parameter_value
	{
		// BUG: parameter_value consumed here will always produce a yyerror,
		//      except for arrays of HEX_STRING values.
		// TODO: Check array type matches parameter type
		$$ = $1;
	}
	| SIGNED_INTEGER '*' small_unsigned_integer // array expansion
	{
		std::string val;

		ArrayParameter* arr = current_parameter->as_field()->as_parameter()->as_array_parameter();
		if(arr == (ArrayParameter*)NULL)
		{
			yyerror("Cannot use array expansion as value for non-array parameter.");
		}
		else
		{
			for(unsigned int i = 0; i < $3; i++)
			{
				val += number_value(arr->get_element_type()->get_datatype(), $1);
			}
		}

		$$ = val;
	}
	| UNSIGNED_INTEGER '*' small_unsigned_integer // array expansion
	{
		std::string val;

		ArrayParameter* arr = current_parameter->as_field()->as_parameter()->as_array_parameter();
		if(arr == (ArrayParameter*)NULL)
		{
			yyerror("Cannot use array expansion as value for non-array parameter.");
		}
		else
		{
			for(unsigned int i = 0; i < $3; i++)
			{
				val += number_value(arr->get_element_type()->get_datatype(), $1);
			}
		}

		$$ = val;
	}
	| REAL '*' small_unsigned_integer // array expansion
	{
		std::string val;

		ArrayParameter* arr = current_parameter->as_field()->as_parameter()->as_array_parameter();
		if(arr == (ArrayParameter*)NULL)
		{
			yyerror("Cannot use array expansion as value for non-array parameter.");
		}
		else
		{
			for(unsigned int i = 0; i < $3; i++)
			{
				val += number_value(arr->get_element_type()->get_datatype(), $1);
			}
		}

		$$ = val;
	}
	| HEX_STRING '*' small_unsigned_integer // array expansion
	{
		std::string val;

		// TODO: Check array type compatible with HEX_STRING,
		//       and check integer bounds if current parameter has integer type.
		ArrayParameter* arr = current_parameter->as_field()->as_parameter()->as_array_parameter();
		if(arr == (ArrayParameter*)NULL)
		{
			yyerror("Cannot use array expansion as value for non-array parameter.");
		}
		else
		{
			for(unsigned int i = 0; i < $3; i++)
			{
				val += $1;
			}
		}
		$$ = val;
	}
	| array_value ',' parameter_value
	{
		// BUG: parameter_value consumed here will always produce a yyerror,
		//      except for arrays of HEX_STRING values.
		// TODO: Check array type matches parameter type
		$$ = $1 + $3;
	}
	;

type_token
	: KW_INT8 { $$ = DT_int8; }
	| KW_INT16 { $$ = DT_int16; }
	| KW_INT32 { $$ = DT_int32; }
	| KW_INT64 { $$ = DT_int64; }
	| KW_UINT8 { $$ = DT_uint8; }
	| KW_UINT16 { $$ = DT_uint16; }
	| KW_UINT32 { $$ = DT_uint32; }
	| KW_UINT64 { $$ = DT_uint64; }
	| KW_FLOAT32 { $$ = DT_float32; }
	| KW_FLOAT64 { $$ = DT_float64; }
	| KW_STRING { $$ = DT_string; }
	| KW_BLOB { $$ = DT_blob; }
	| KW_CHAR { $$ = DT_char; }
	;

keyword_list
	: empty { current_keyword_list.clear_keywords(); }
	| keyword_list KEYWORD { current_keyword_list.add_keyword($2); }
	;

no_keyword_list
	: keyword_list
	{
		if(current_keyword_list.get_num_keywords() != 0)
		{
			yyerror("Keywords are not allowed here.");
		}
	}
	;

molecular_field
	: IDENTIFIER ':' { current_molecular = new MolecularField($1, current_class); }
	  molecular_atom_list { $$ = current_molecular; }
	;

atomic_name
	: IDENTIFIER
	{
		Field *field = current_class->get_field_by_name($1);
		$$ = (AtomicField *)NULL;
		if(field == (Field *)NULL)
		{
			yyerror("Unknown field: " + $1);
		}
		else
		{
			$$ = field->as_atomic_field();
			if($$ == (AtomicField*)NULL)
			{
				yyerror("Not an atomic field: " + $1);
			}
		}
	}
	;

molecular_atom_list
	: atomic_name
	{
		if($1 != (AtomicField *)NULL)
		{
			current_molecular->add_atomic($1);
		}
	}
	| molecular_atom_list ',' atomic_name
	{
		if($3 != (AtomicField *)NULL)
		{
			current_molecular->add_atomic($3);
			if(!current_molecular->compare_keywords(*$3))
			{
				yyerror("Mismatched keywords in molecule between " +
				current_molecular->get_atomic(0)->get_name() + " and " +
				$3->get_name());
			}
		}
	}
	;

empty
	:
	;


%% /* Start helper function section */

std::string number_value(DataType type, double &number)
{
	switch(type)
	{
		case DT_float32:
		{
			float v = number;
			if(v == INFINITY || v == -INFINITY)
			{
				yyerror("Value is out of range for type 'float32'.");
			}

			return std::string((char*)&v, sizeof(float));
		}
		case DT_float64:
		{
			return std::string((char*)&number, sizeof(double));
		}
		case DT_int8:
		case DT_int16:
		case DT_int32:
		case DT_int64:
		case DT_uint8:
		case DT_uint16:
		case DT_uint32:
		case DT_uint64:
		{
			yyerror("Cannot use floating-point value for integer datatype.");
			return std::string();
		}
		default:
		{
			yyerror("Cannot use floating-point value for non-numeric datatype.");
			return std::string();
		}
	}
}

std::string number_value(DataType type, int64_t &number)
{
	switch(type)
	{
		case DT_int8:
		{
			if(INT8_MIN > number || number > INT8_MAX)
			{
				yyerror("Signed integer out of range for type 'int8'.");
			}

			int8_t v = number;
			return std::string((char*)&v, sizeof(int8_t));
		}
		case DT_int16:
		{
			if(INT16_MIN > number || number > INT16_MAX)
			{
				yyerror("Signed integer out of range for type 'int16'.");
			}

			uint16_t v = number;
			return std::string((char*)&v, sizeof(int16_t));
		}
		case DT_int32:
		{
			if(INT32_MIN > number || number > INT32_MAX)
			{
				yyerror("Signed integer out of range for type 'int32'.");
			}

			int32_t v = number;
			return std::string((char*)&v, sizeof(int32_t));
		}
		case DT_int64:
		{
			return std::string((char*)&number, sizeof(int64_t));
		}
		case DT_uint8:
		case DT_uint16:
		case DT_uint32:
		case DT_uint64:
		{
			if(number < 0)
			{
				yyerror("Can't use negative value for unsigned integer datatype.");
			}
			uint64_t v = number;
			return number_value(type, v);
		}
		case DT_float32:
		case DT_float64:
		{
			// Note: Expecting number to be converted to a double by value (ie. -1 becomes -1.0)
			double v = number;
			return number_value(type, v);
		}
		default:
		{
			yyerror("Cannot use signed integer value for non-numeric datatype.");
			return std::string();
		}
	}
}

std::string number_value(DataType type, uint64_t &number)
{
	switch(type)
	{
		case DT_uint8:
		{
			if(number > UINT8_MAX)
			{
				yyerror("Unsigned integer out of range for type 'uint8'.");
			}

			uint8_t v = number;
			return std::string((char*)&v, sizeof(uint8_t));
		}
		case DT_uint16:
		{
			if(number > UINT16_MAX)
			{
				yyerror("Unsigned integer out of range for type 'uint16'.");
			}

			uint16_t v = number;
			return std::string((char*)&v, sizeof(uint16_t));
		}
		case DT_uint32:
		{
			if(number > UINT32_MAX)
			{
				yyerror("Unsigned integer out of range for type 'uint32'.");
			}

			uint32_t v = number;
			return std::string((char*)&v, sizeof(uint32_t));
		}
		case DT_uint64:
		{
			return std::string((char*)&number, sizeof(uint64_t));
		}
		case DT_int8:
		case DT_int16:
		case DT_int32:
		case DT_int64:
		{
			if(number > INT64_MAX)
			{
				yyerror("Unsigned integer out of range for signed integer datatype.");
			}
			int64_t v = number;
			return number_value(type, v);
		}
		case DT_float32:
		case DT_float64:
		{
			// Note: Expecting number to be converted to a double by value (ie. 3 becomes 3.0)
			double v = number;
			return number_value(type, v);
		}
		default:
		{
			yyerror("Cannot use unsigned integer value for non-numeric datatype.");
			return std::string();
		}
	}
}

Parameter* param_with_modulus(Parameter* p, double mod)
{
	SimpleParameter *simple_param = p->as_simple_parameter();
	if(simple_param == NULL
	|| simple_param->get_typedef() != (Typedef*)NULL
	|| !simple_param->is_numeric_type())
	{
		yyerror("A modulus is only valid on a numeric type.");
	}
	else if(!simple_param->set_modulus(mod))
	{
		yyerror("Invalid modulus.");
	}

	return simple_param;
}

Parameter* param_with_divisor(Parameter* p, uint32_t div)
{
	SimpleParameter *simple_param = p->as_simple_parameter();
	if(simple_param == NULL
	|| simple_param->get_typedef() != (Typedef*)NULL
	|| !simple_param->is_numeric_type())
	{
		yyerror("A divisor is only valid on a numeric type.");

	}
	else if(!simple_param->set_divisor(div))
	{
		yyerror("Invalid divisor.");
	}

	return simple_param;	
}


} // close namespace dclass
